{2}# -*- coding: utf-8 -*-
#--------------------------------------------------------------------------
# perl-test-5220delta.pl
#--------------------------------------------------------------------------
# REF: https://metacpan.org/pod/distribution/perl/pod/perldelta.pod
# maybe future ref: https://metacpan.org/pod/distribution/perl/pod/perl5220delta.pod
# also: http://perltricks.com/article/165/2015/4/10/A-preview-of-Perl-5-22
#
#--------------------------------------------------------------------------
# Kein-Hong Man <keinhong@gmail.com> Public Domain 20151217
#--------------------------------------------------------------------------
# 20151217	initial document
# 20151218	updated tests and comments
#--------------------------------------------------------------------------
{0}
{5}use{0} {6}v5.22{10};{0}			{2}# may be needed
{0}
{2}#--------------------------------------------------------------------------
# New bitwise operators
#--------------------------------------------------------------------------
{0}
{5}use{0} {11}feature{0} {7}'bitwise'{0}		{2}# enable feature, warning enabled
{5}use{0} {11}experimental{0} {6}"bitwise"{10};{0}	{2}# enable feature, warning disabled
{0}
{2}# numerical operands
{4}10{10}&{4}20{0}  {4}10{10}|{4}20{0}   {4}10{10}^{4}20{0} {10}~{4}10{0}
{12}$a{10}&{6}"8"{0} {12}$a{10}|{6}"8"{0} {12}$a{10}^{6}"8"{0} {10}~{12}$a{0} {10}~{6}"8"{0}

{2}# string operands
{7}'0'{10}&.{6}"8"{0} {7}'0'{10}|.{6}"8"{0} {7}'0'{10}^.{6}"8"{0} {10}~.{7}'0'{0} {10}~.{6}"8"{0}
{2}# the following is AMBIGUOUS, perl sees 10 and not .10 only when bitwise feature is enabled
# so it's feature-setting-dependent, no plans to change current behaviour
{0} {12}$a{10}&{4}.10{0}   {12}$a{10}|{4}.10{0}   {12}$a{10}^{4}.10{0}  {10}~.{12}$a{0}  {10}~{4}.10{0}

{2}# assignment variants
{12}$a{10}&={4}10{10};{0}    {12}$a{10}|={4}10{10};{0}    {12}$a{10}^={4}10{10};{0}
{12}$b{10}&.={7}'20'{10};{0} {12}$b{10}|.={7}'20'{10};{0} {12}$b{10}^.={7}'20'{10};{0}
{12}$c{10}&={6}"30"{10};{0}  {12}$c{10}|={6}"30"{10};{0}  {12}$c{10}^={6}"30"{10};{0}
{12}$d{10}&.={12}$e{10};{0}   {12}$d{10}|.={12}$e{10};{0}   {12}$d{10}^.={12}$e{10};{0}

{2}#--------------------------------------------------------------------------
# New double-diamond operator
#--------------------------------------------------------------------------
# <<>> is like <> but each element of @ARGV will be treated as an actual file name
{0}
{2}# example snippet from brian d foy's blog post
{5}while{10}({0} {10}<<>>{0} {10}){0} {10}{{0}  {2}# new, safe line input operator
{0}	{10}...;{0}
	{10}}{0}

{2}#--------------------------------------------------------------------------
# New \b boundaries in regular expressions
#--------------------------------------------------------------------------
{0}
{29}qr/\b{gcb}/{0}
{29}qr/\b{wb}/{0}
{29}qr/\b{sb}/{0}

{2}#--------------------------------------------------------------------------
# Non-Capturing Regular Expression Flag
#--------------------------------------------------------------------------
# disables capturing and filling in $1, $2, etc
{0}
{6}"hello"{0} {10}=~{0} {17}/(hi|hello)/n{10};{0} {2}# $1 is not set
{0}
{2}#--------------------------------------------------------------------------
# Aliasing via reference
#--------------------------------------------------------------------------
# Variables and subroutines can now be aliased by assigning to a reference
{0}
{10}\{12}$c{0} {10}={0} {10}\{12}$d{10};{0}
{10}\&{11}x{0} {10}={0} {10}\&{11}y{10};{0}

{2}# Aliasing can also be applied to foreach iterator variables
{0}
{5}foreach{0} {10}\{14}%hash{0} {10}({13}@array_of_hash_refs{10}){0} {10}{{0} {10}...{0} {10}}{0}

{2}# example snippet from brian d foy's blog post
{0}
{5}use{0} {11}feature{0} {30}qw(refaliasing){10};{0}

{10}\{14}%other_hash{0} {10}={0} {10}\{14}%hash{10};{0}

{5}use{0} {6}v5.22{10};{0}
{5}use{0} {11}feature{0} {30}qw(refaliasing){10};{0}

{5}foreach{0} {10}\{5}my{0} {14}%hash{0} {10}({0} {13}@array_of_hashes{0} {10}){0} {10}{{0} {2}# named hash control variable
{0}	{5}foreach{0} {5}my{0} {12}$key{0} {10}({0} {5}keys{0} {14}%hash{0} {10}){0} {10}{{0} {2}# named hash now!
{0}		{10}...;{0}
		{10}}{0}
	{10}}{0}

{2}#--------------------------------------------------------------------------
# New :const subroutine attribute
#--------------------------------------------------------------------------
{0}
{5}my{0} {12}$x{0} {10}={0} {4}54321{10};{0}
{15}*INLINED{0} {10}={0} {5}sub{0} {10}:{0} {11}const{0} {10}{{0} {12}$x{0} {10}};{0}
{12}$x{10}++;{0}

{2}# more examples of attributes
# (not 5.22 stuff, but some general examples for study, useful for
#  handling subroutine signature and subroutine prototype highlighting)
{0}
{5}sub{0} {11}foo{0} {10}:{0} {11}lvalue{0} {10};{0}

{5}package{0} {11}X{10};{0}
{5}sub{0} {11}Y{10}::{11}x{0} {10}:{0} {11}lvalue{0} {10}{{0} {4}1{0} {10}}{0}

{5}package{0} {11}X{10};{0}
{5}sub{0} {11}foo{0} {10}{{0} {4}1{0} {10}}{0}
{5}package{0} {11}Y{10};{0}
{5}BEGIN{0} {10}{{0} {15}*bar{0} {10}={0} {10}\&{11}X{10}::{11}foo{10};{0} {10}}{0}
{5}package{0} {11}Z{10};{0}
{5}sub{0} {11}Y{10}::{11}bar{0} {10}:{0} {11}lvalue{0} {10};{0}

{2}# built-in attributes for subroutines:
{11}lvalue{0} {11}method{0} {5}prototype{10}(..){0} {11}locked{0} {11}const{0}

{2}#--------------------------------------------------------------------------
# Repetition in list assignment
#--------------------------------------------------------------------------
{0}
{2}# example snippet from brian d foy's blog post
{5}use{0} {6}v5.22{10};{0}
{5}my{10}({5}undef{10},{0} {12}$card_num{10},{0} {10}({5}undef{10})x{4}3{10},{0} {12}$count{10}){0} {10}={0} {5}split{0} {17}/:/{10};{0}

{10}({5}undef{10},{5}undef{10},{12}$foo{10}){0} {10}={0} {11}that_function{10}(){0}
{2}# is equivalent to 
{10}(({5}undef{10})x{4}2{10},{0} {12}$foo{10}){0} {10}={0} {11}that_function{10}(){0}

{2}#--------------------------------------------------------------------------
# Floating point parsing has been improved
#--------------------------------------------------------------------------
# Hexadecimal floating point literals
{0}
{2}# some hex floats from a program by Rick Regan
# appropriated and extended from Lua 5.2.x test cases
# tested on perl 5.22/cygwin
{0}
{4}0x1p-1074{10};{0}
{4}0x3.3333333333334p-5{10};{0}
{4}0xcc.ccccccccccdp-11{10};{0}
{4}0x1p+1{10};{0}
{4}0x1p-6{10};{0}
{4}0x1.b7p-1{10};{0}
{4}0x1.fffffffffffffp+1023{10};{0}
{4}0x1p-1022{10};{0}
{4}0X1.921FB4D12D84AP+1{10};{0}
{4}0x1.999999999999ap-4{10};{0}

{2}# additional test cases for characterization
{4}0x1p-1074{10}.{0}		{2}# dot is a string operator
{4}0x.ABCDEFp10{0}		{2}# legal, dot immediately after 0x
{4}0x{10}.{11}p10{0}			{2}# perl allows 0x as a zero, then concat with p10 bareword
{4}0x{10}.{11}p{0} {4}0x0{10}.{11}p{0}		{2}# dot then bareword
{4}0x_0_.A_BC___DEF_p1_0{0}	{2}# legal hex float, underscores are mostly allowed
{4}0x0{10}.{11}_ABCDEFp10{0}		{2}# _ABCDEFp10 is a bareword, no underscore allowed after dot
{0}
{2}# illegal, but does not use error highlighting
{4}0x0p1{11}ABC{0}		{2}# illegal, highlighted as 0x0p1 abut with bareword ABC 
{0}
{2}# allowed to FAIL for now
{4}0x0.ABCDEFp_10{0}		{2}# ABCDEFp_10 is a bareword, '_10' exponent not allowed
{4}0xp{0} {4}0xp1{0} {4}0x0.0p{0}		{2}# syntax errors
{4}0x41.65{10}.{4}65{0} 		{2}# hex dot number, but lexer now fails with 0x41.65 left as a partial hex float
{0}
{2}#--------------------------------------------------------------------------
# Support for ?PATTERN? without explicit operator has been removed
#--------------------------------------------------------------------------
# ?PATTERN? must now be written as m?PATTERN?
{0}
{10}?{11}PATTERN{10}?{0}	{2}# does not work in current LexPerl anyway, NO ACTION NEEDED
{17}m?PATTERN?{0}

{2}#--------------------------------------------------------------------------
# end of test file
#--------------------------------------------------------------------------
